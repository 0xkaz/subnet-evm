// Code generated
// This file is a generated precompile contract with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

// There are some must-be-done changes waiting in the file. Each area requiring you to add your code is marked with CUSTOM CODE to make them easy to find and modify.
// Additionally there are other files you need to edit to activate your precompile.
// These areas are highlighted with comments "ADD YOUR PRECOMPILE HERE".
// For testing take a look at other precompile tests in core/stateful_precompile_test.go

/* General guidelines for precompile development:
1- Read the comment and set a suitable contract address in precompile/params.go. E.g:
	WarpMessengerAddress = common.HexToAddress("ASUITABLEHEXADDRESS")
2- Set gas costs here
3- It is recommended to only modify code in the highlighted areas marked with "CUSTOM CODE STARTS HERE". Modifying code outside of these areas should be done with caution and with a deep understanding of how these changes may impact the EVM.
Typically, custom codes are required in only those areas.
4- Add your upgradable config in params/precompile_config.go
5- Add your precompile upgrade in params/config.go
6- Add your solidity interface and test contract to contract-examples/contracts
7- Write solidity tests for your precompile in contract-examples/test
8- Create your genesis with your precompile enabled in tests/e2e/genesis/
9- Create e2e test for your solidity test in tests/e2e/solidity/suites.go
10- Run your e2e precompile Solidity tests with './scripts/run_ginkgo.sh'

*/

package precompile

import (
	"context"
	"encoding/json"
	"errors"
	"math/big"
	"strings"

	"github.com/ethereum/go-ethereum/log"

	"github.com/ava-labs/avalanchego/utils/set"

	"github.com/ethereum/go-ethereum/rlp"

	"github.com/ava-labs/avalanchego/snow"
	"github.com/ava-labs/avalanchego/snow/engine/snowman/block"

	"github.com/ava-labs/avalanchego/vms/platformvm/teleporter"

	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/vmerrs"

	"github.com/ethereum/go-ethereum/common"
)

const (
	GetBlockchainIdGasCost                              uint64 = 5_000   // SET A GAS COST HERE
	GetVerifiedCrossChainMessageGasCost                 uint64 = 100_000 // SET A GAS COST HERE
	GetVerifiedCrossChainMessageGasCostPerAggregatedKey uint64 = 1_000
	SendCrossChainMessageGasCost                        uint64 = 100_000 // SET A GAS COST HERE

	// WarpMessengerRawABI contains the raw ABI of WarpMessenger contract.
	WarpMessengerRawABI  = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"destinationChainID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"destinationAddress\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"SendCrossChainMessage\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getBlockchainId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"chainID\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"messageIndex\",\"type\":\"uint256\"}],\"name\":\"getVerifiedCrossChainMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"sourceChainID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"senderAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationChainID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"internalType\":\"structCrossChainMessage\",\"name\":\"message\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"destinationChainID\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationAddress\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"sendCrossChainMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"
	SubmitMessageEventID = "da2b1cd3e6664863b4ad90f53a4e14fca9fc00f3f0e01e5c7b236a4355b6591a" // Keccack256("SubmitMessage(bytes32,uint256)")

	// Default stake threshold for aggregate signature verification. (67%)
	// TODO: This should be made configuration on the VM level.
	WarpQuorumNumerator   = 67
	WarpQuorumDenominator = 100
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
)

// Singleton StatefulPrecompiledContract and signatures.
var (
	_ StatefulPrecompileConfig = &WarpMessengerConfig{}

	WarpMessengerABI abi.ABI // will be initialized by init function

	WarpMessengerPrecompile StatefulPrecompiledContract // will be initialized by init function
)

// WarpMessengerConfig implements the StatefulPrecompileConfig
// interface while adding in the WarpMessenger specific precompile address.
type WarpMessengerConfig struct {
	UpgradeableConfig
}

func (c *WarpMessengerConfig) verifyPredicate(snowCtx *snow.Context, proposerVMBlockCtx *block.Context, storageSlots []byte) error {
	// The proposer VM block context is required to verify aggregate signatures.
	if proposerVMBlockCtx == nil {
		return errors.New("missing proposer VM block context")
	}

	// If there are no storage slots, we consider the predicate to be valid because
	// there are no messages to be received. If receiveCrossChainMessage is later
	// called in this transaction, the execution will revert, but the transaction
	// will still be included in the chain.
	if len(storageSlots) == 0 {
		return nil
	}

	// RLP decode the list of signed messages.
	var messagesBytes [][]byte
	err := rlp.DecodeBytes(storageSlots, &messagesBytes)
	if err != nil {
		return err
	}

	// Check that each message was intended for this chain, and verify the aggregate signature of each message.
	for _, messageBytes := range messagesBytes {
		message, err := teleporter.ParseMessage(messageBytes)
		if err != nil {
			return err
		}

		// TODO: Should we add a special chain ID that is allowed as the "anycast" chain ID? Just need to think through if there are any security implications.
		if message.DestinationChainID != snowCtx.ChainID {
			return errors.New("wrong chain id")
		}

		err = message.Signature.Verify(
			context.Background(),
			&message.UnsignedMessage,
			snowCtx.ValidatorState,
			proposerVMBlockCtx.PChainHeight,
			WarpQuorumNumerator,
			WarpQuorumDenominator)
		if err != nil {
			return err
		}
		log.Info("Teleporter message verification passed.")
	}

	log.Info("Receive cross subnet message predicate passed.")
	return nil
}

func (c *WarpMessengerConfig) Predicate() PredicateFunc {
	return c.verifyPredicate
}

func (c *WarpMessengerConfig) OnAccept() OnAcceptFunc {
	return nil
}

// CrossChainMessage is an auto generated low-level Go binding around an user-defined struct.
type CrossChainMessage struct {
	SourceChainID      [32]byte
	SenderAddress      [32]byte
	DestinationChainID [32]byte
	DestinationAddress [32]byte
	Payload            []byte
}

type GetVerifiedCrossChainMessageOutput struct {
	Message CrossChainMessage
	Success bool
}

type SendCrossChainMessageInput struct {
	DestinationChainID [32]byte
	DestinationAddress [32]byte
	Payload            []byte
}

func init() {
	parsed, err := abi.JSON(strings.NewReader(WarpMessengerRawABI))
	if err != nil {
		panic(err)
	}
	WarpMessengerABI = parsed

	WarpMessengerPrecompile = createWarpMessengerPrecompile(WarpMessengerAddress)
}

// NewWarpMessengerConfig returns a config for a network upgrade at [blockTimestamp] that enables
// WarpMessenger .
func NewWarpMessengerConfig(blockTimestamp *big.Int) *WarpMessengerConfig {
	return &WarpMessengerConfig{

		UpgradeableConfig: UpgradeableConfig{BlockTimestamp: blockTimestamp},
	}
}

// NewDisableWarpMessengerConfig returns config for a network upgrade at [blockTimestamp]
// that disables WarpMessenger.
func NewDisableWarpMessengerConfig(blockTimestamp *big.Int) *WarpMessengerConfig {
	return &WarpMessengerConfig{
		UpgradeableConfig: UpgradeableConfig{
			BlockTimestamp: blockTimestamp,
			Disable:        true,
		},
	}
}

// Equal returns true if [s] is a [*WarpMessengerConfig] and it has been configured identical to [c].
func (c *WarpMessengerConfig) Equal(s StatefulPrecompileConfig) bool {
	// typecast before comparison
	other, ok := (s).(*WarpMessengerConfig)
	if !ok {
		return false
	}
	// CUSTOM CODE STARTS HERE
	// modify this boolean accordingly with your custom WarpMessengerConfig, to check if [other] and the current [c] are equal
	// if WarpMessengerConfig contains only UpgradeableConfig  you can skip modifying it.
	equals := c.UpgradeableConfig.Equal(&other.UpgradeableConfig)
	return equals
}

// String returns a string representation of the WarpMessengerConfig.
func (c *WarpMessengerConfig) String() string {
	bytes, _ := json.Marshal(c)
	return string(bytes)
}

// Address returns the address of the WarpMessenger. Addresses reside under the precompile/params.go
// Select a non-conflicting address and set it in the params.go.
func (c *WarpMessengerConfig) Address() common.Address {
	return WarpMessengerAddress
}

// Configure configures [state] with the initial configuration.
func (c *WarpMessengerConfig) Configure(_ ChainConfig, state StateDB, _ BlockContext) {

	// CUSTOM CODE STARTS HERE
}

// Contract returns the singleton stateful precompiled contract to be used for WarpMessenger.
func (c *WarpMessengerConfig) Contract() StatefulPrecompiledContract {
	return WarpMessengerPrecompile
}

// Verify tries to verify WarpMessengerConfig and returns an error accordingly.
func (c *WarpMessengerConfig) Verify() error {

	// CUSTOM CODE STARTS HERE
	// Add your own custom verify code for WarpMessengerConfig here
	// and return an error accordingly
	return nil
}

// PackGetBlockchainId packs the include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackGetBlockchainId() ([]byte, error) {
	return WarpMessengerABI.Pack("getBlockchainId")
}

// PackGetBlockchainIdOutput attempts to pack given chainID of type [32]byte
// to conform the ABI outputs.
func PackGetBlockchainIdOutput(chainID [32]byte) ([]byte, error) {
	return WarpMessengerABI.PackOutput("getBlockchainId", chainID)
}

func getBlockchainId(accessibleState PrecompileAccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = deductGas(suppliedGas, GetBlockchainIdGasCost); err != nil {
		return nil, 0, err
	}

	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}

	packedOutput, err := PackGetBlockchainIdOutput(accessibleState.GetSnowContext().ChainID)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackGetVerifiedCrossChainMessageInput attempts to unpack [input] into the *big.Int type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackGetVerifiedCrossChainMessageInput(input []byte) (*big.Int, error) {
	res, err := WarpMessengerABI.UnpackInput("getVerifiedCrossChainMessage", input)
	if err != nil {
		return big.NewInt(0), err
	}
	unpacked := *abi.ConvertType(res[0], new(*big.Int)).(**big.Int)
	return unpacked, nil
}

// PackGetVerifiedCrossChainMessage packs [messageIndex] of type *big.Int into the appropriate arguments for getVerifiedCrossChainMessage.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackGetVerifiedCrossChainMessage(messageIndex *big.Int) ([]byte, error) {
	return WarpMessengerABI.Pack("getVerifiedCrossChainMessage", messageIndex)
}

// PackGetVerifiedCrossChainMessageOutput attempts to pack given [outputStruct] of type GetVerifiedCrossChainMessageOutput
// to conform the ABI outputs.
func PackGetVerifiedCrossChainMessageOutput(outputStruct GetVerifiedCrossChainMessageOutput) ([]byte, error) {
	return WarpMessengerABI.PackOutput("getVerifiedCrossChainMessage",
		outputStruct.Message,
		outputStruct.Success,
	)
}

func getVerifiedCrossChainMessage(accessibleState PrecompileAccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = deductGas(suppliedGas, GetVerifiedCrossChainMessageGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the GetVerifiedCrossChainMessageInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [messageIndex] variable in your code
	inputIndex, err := UnpackGetVerifiedCrossChainMessageInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	storageSlots, exists := accessibleState.GetStateDB().GetPredicateStorageSlots(WarpMessengerAddress)
	if !exists || storageSlots == nil {
		return nil, remainingGas, errors.New("missing access list storage slots from precompile during execution")
	}

	var signedMessages [][]byte
	err = rlp.DecodeBytes(storageSlots, &signedMessages)
	if err != nil {
		return nil, remainingGas, err
	}

	// Check that the message index exists.
	if !inputIndex.IsInt64() {
		return nil, remainingGas, errors.New("invalid message index")
	}
	messageIndex := inputIndex.Int64()
	if len(signedMessages) <= int(messageIndex) {
		return nil, remainingGas, errors.New("invalid message index")
	}

	// Parse the raw message to be processed.
	signedMessage := signedMessages[messageIndex]
	message, err := teleporter.ParseMessage(signedMessage)
	if err != nil {
		return nil, remainingGas, err
	}

	// Charge gas per validator included in the aggregate signature
	bitSetSignature, ok := message.Signature.(*teleporter.BitSetSignature)
	if !ok {
		return nil, remainingGas, errors.New("invalid aggregate signature")
	}

	numSigners := set.BitsFromBytes(bitSetSignature.Signers).HammingWeight()
	if remainingGas, err = deductGas(remainingGas, GetVerifiedCrossChainMessageGasCostPerAggregatedKey*uint64(numSigners)); err != nil {
		return nil, 0, err
	}

	var warpMessage CrossChainMessage
	_, err = Codec.Unmarshal(message.Payload, &warpMessage)
	if err != nil {
		return nil, remainingGas, err
	}

	output := GetVerifiedCrossChainMessageOutput{
		Message: warpMessage,
		Success: true,
	}

	packedOutput, err := PackGetVerifiedCrossChainMessageOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackSendCrossChainMessageInput attempts to unpack [input] into the arguments for the SendCrossChainMessageInput{}
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackSendCrossChainMessageInput(input []byte) (SendCrossChainMessageInput, error) {
	inputStruct := SendCrossChainMessageInput{}
	err := WarpMessengerABI.UnpackInputIntoInterface(&inputStruct, "sendCrossChainMessage", input)

	return inputStruct, err
}

// PackSendCrossChainMessage packs [inputStruct] of type SendCrossChainMessageInput into the appropriate arguments for sendCrossChainMessage.
func PackSendCrossChainMessage(inputStruct SendCrossChainMessageInput) ([]byte, error) {
	return WarpMessengerABI.Pack("sendCrossChainMessage", inputStruct.DestinationChainID, inputStruct.DestinationAddress, inputStruct.Payload)
}

func sendCrossChainMessage(accessibleState PrecompileAccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = deductGas(suppliedGas, SendCrossChainMessageGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}

	// attempts to unpack [input] into the arguments to the SendCrossChainMessageInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackSendCrossChainMessageInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	message := &CrossChainMessage{
		SourceChainID:      accessibleState.GetSnowContext().ChainID,
		SenderAddress:      caller.Hash(),
		DestinationChainID: inputStruct.DestinationChainID,
		DestinationAddress: inputStruct.DestinationAddress,
		Payload:            inputStruct.Payload,
	}

	data, err := Codec.Marshal(Version, message)
	if err != nil {
		return nil, remainingGas, err
	}

	accessibleState.GetStateDB().AddLog(
		WarpMessengerAddress,
		[]common.Hash{
			common.HexToHash(SubmitMessageEventID),
			message.SourceChainID,
			message.DestinationChainID,
		},
		data,
		accessibleState.GetBlockContext().Number().Uint64())

	return []byte{}, remainingGas, nil
}

// createWarpMessengerPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.

func createWarpMessengerPrecompile(precompileAddr common.Address) StatefulPrecompiledContract {
	var functions []*statefulPrecompileFunction

	methodGetBlockchainId, ok := WarpMessengerABI.Methods["getBlockchainId"]
	if !ok {
		panic("given method does not exist in the ABI")
	}
	functions = append(functions, newStatefulPrecompileFunction(methodGetBlockchainId.ID, getBlockchainId))

	methodGetVerifiedCrossChainMessage, ok := WarpMessengerABI.Methods["getVerifiedCrossChainMessage"]
	if !ok {
		panic("given method does not exist in the ABI")
	}
	functions = append(functions, newStatefulPrecompileFunction(methodGetVerifiedCrossChainMessage.ID, getVerifiedCrossChainMessage))

	methodSendCrossChainMessage, ok := WarpMessengerABI.Methods["sendCrossChainMessage"]
	if !ok {
		panic("given method does not exist in the ABI")
	}
	functions = append(functions, newStatefulPrecompileFunction(methodSendCrossChainMessage.ID, sendCrossChainMessage))

	// Construct the contract with no fallback function.
	contract := newStatefulPrecompileWithFunctionSelectors(nil, functions)
	return contract
}
