// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

// There are some must-be-done changes waiting in the file. Each area requiring you to add your code is marked with CUSTOM CODE to make them easy to find and modify.
// Additionally there are other files you need to edit to activate your precompile.
// These areas are highlighted with comments "ADD YOUR PRECOMPILE HERE".
// For testing take a look at other precompile tests in contract_test.go and config_test.go in other precompile folders.
// See the tutorial in https://docs.avax.network/subnets/hello-world-precompile-tutorial for more information about precompile development.

/* General guidelines for precompile development:
1- Read the comment and set a suitable contract address in generated module.go. E.g:
	ContractAddress = common.HexToAddress("ASUITABLEHEXADDRESS")
2- Set a suitable config key in generated module.go. E.g: "yourPrecompileConfig"
3- It is recommended to only modify code in the highlighted areas marked with "CUSTOM CODE STARTS HERE". Typically, custom codes are required in only those areas.
Modifying code outside of these areas should be done with caution and with a deep understanding of how these changes may impact the EVM.
4- Set gas costs in generated contract.go
5- Add your config unit tests under generated package config_test.go
6- Add your contract unit tests undertgenerated package contract_test.go
7- Additionally you can add a full-fledged VM test for your precompile under plugin/vm/vm_test.go. See existing precompile tests for examples.
8- Add your solidity interface and test contract to contract-examples/contracts
9- Write solidity tests for your precompile in contract-examples/test
10- Create your genesis with your precompile enabled in tests/e2e/genesis/
11- Create e2e test for your solidity test in tests/e2e/solidity/suites.go
12- Run your e2e precompile Solidity tests with 'E2E=true ./scripts/run.sh'
*/

package helloworld

import (
	"errors"
	"fmt"
	"math/big"

	"github.com/ava-labs/subnet-evm/accounts/abi"
	"github.com/ava-labs/subnet-evm/precompile/contract"
	"github.com/ava-labs/subnet-evm/vmerrs"

	_ "embed"

	"github.com/ethereum/go-ethereum/common"
)

const (
	// Gas costs for each function. These are set to 0 by default.
	// You should set a gas cost for each function in your contract.
	// Generally, you should not set gas costs very low as this may cause your network to be vulnerable to DoS attacks.
	// There are some predefined gas costs in contract/utils.go that you can use.}
	SayHelloGasCost    uint64 = 0 // SET A GAS COST HERE
	SetGreetingGasCost uint64 = 0 // SET A GAS COST HERE
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
	_ = errors.New
	_ = big.NewInt
)

// Singleton StatefulPrecompiledContract and signatures.
var (

	// HelloWorldRawABI contains the raw ABI of HelloWorld contract.
	//go:embed contract.abi
	HelloWorldRawABI string

	HelloWorldABI = contract.ParseABI(HelloWorldRawABI)

	HelloWorldPrecompile = createHelloWorldPrecompile()
)

// PackSayHello packs the include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackSayHello() ([]byte, error) {
	return HelloWorldABI.Pack("sayHello")
}

// PackSayHelloOutput attempts to pack given result of type string
// to conform the ABI outputs.
func PackSayHelloOutput(result string) ([]byte, error) {
	return HelloWorldABI.PackOutput("sayHello", result)
}

func sayHello(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, SayHelloGasCost); err != nil {
		return nil, 0, err
	}
	// no input provided for this function

	// CUSTOM CODE STARTS HERE

	var output string // CUSTOM CODE FOR AN OUTPUT
	packedOutput, err := PackSayHelloOutput(output)
	if err != nil {
		return nil, remainingGas, err
	}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// UnpackSetGreetingInput attempts to unpack [input] into the string type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackSetGreetingInput(input []byte) (string, error) {
	res, err := HelloWorldABI.UnpackInput("setGreeting", input)
	if err != nil {
		return "", err
	}
	unpacked := *abi.ConvertType(res[0], new(string)).(*string)
	return unpacked, nil
}

// PackSetGreeting packs [response] of type string into the appropriate arguments for setGreeting.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackSetGreeting(response string) ([]byte, error) {
	return HelloWorldABI.Pack("setGreeting", response)
}

func setGreeting(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
	if remainingGas, err = contract.DeductGas(suppliedGas, SetGreetingGasCost); err != nil {
		return nil, 0, err
	}
	if readOnly {
		return nil, remainingGas, vmerrs.ErrWriteProtection
	}
	// attempts to unpack [input] into the arguments to the SetGreetingInput.
	// Assumes that [input] does not include selector
	// You can use unpacked [inputStruct] variable in your code
	inputStruct, err := UnpackSetGreetingInput(input)
	if err != nil {
		return nil, remainingGas, err
	}

	// CUSTOM CODE STARTS HERE
	_ = inputStruct // CUSTOM CODE OPERATES ON INPUT
	// this function does not return an output, leave this one as is
	packedOutput := []byte{}

	// Return the packed output and the remaining gas
	return packedOutput, remainingGas, nil
}

// createHelloWorldPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.

func createHelloWorldPrecompile() contract.StatefulPrecompiledContract {
	var functions []*contract.StatefulPrecompileFunction

	abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
		"sayHello":    sayHello,
		"setGreeting": setGreeting,
	}

	for name, function := range abiFunctionMap {
		method, ok := HelloWorldABI.Methods[name]
		if !ok {
			panic(fmt.Errorf("given method (%s) does not exist in the ABI", name))
		}
		functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
	}
	// Construct the contract with no fallback function.
	statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
	if err != nil {
		panic(err)
	}
	return statefulContract
}
